---
title: "01.digital logic circuit design"
excerpt: ""

categories:
  - DigitalLogicDesign
tags:
  - 논리회로
  - 디지털시스템
  - 트랜지스터 
  - FSM
  - 하드웨어

permalink: /DigitalLogicDesign/01/

toc: true
toc_sticky: true

date: 2025-10-10
last_modified_at: 2025-10-10
---


# 논리회로설계 1강 정리  
> 소프트웨어 명령이 하드웨어 회로를 어떻게 제어하는가

---

## 1. 논리회로의 역할: SW와 HW의 연결고리

이 페이지는 소프트웨어(SW)의 명령이 어떻게 물리적인 하드웨어(HW) 회로(Circuit)를 동작시키는지,  
그 중간 다리 역할을 하는 ‘논리회로(Logic Circuit)’의 핵심 동작 원리를 설명하고 있습니다.

가장 핵심적인 개념은 **논리회로가 소프트웨어의 추상적인 명령어(코드)**와  
**하드웨어의 물리적인 전기 신호(Voltage)** 사이의 ‘중간 지대’ 역할을 한다는 것입니다.

우리가 C언어나 다른 프로그래밍 언어로 코드를 작성하면(App/SW),  
그 코드는 결국 컴퓨터가 이해할 수 있는 **0과 1의 나열(기계어)**로 번역됩니다.  
(e.g., 1010111000…)

논리회로는 바로 이 **0과 1의 디지털 신호를 받아 실제 전기 회로를 제어하는 역할**을 수행합니다.

---

## 2. 논리회로의 동작 원리: 전압으로 스위치 제어하기

슬라이드의 내용을 단계별로 살펴보면 다음과 같습니다.

### SW의 명령 → 전기적 전압 생성

소프트웨어에서 만들어진 디지털 신호 ‘1’은 **높은 전압(High, VDD)**으로,  
‘0’은 **낮은 전압(Low, GND)**으로 변환됩니다.  
이것이 논리회로 동작의 시작입니다.

### 전압 → MOS 스위치 제어

이 전압 신호는 **MOSFET**과 같은 트랜지스터의 **게이트(Gate)** 단자로 전달됩니다.  
MOSFET은 일종의 ‘전기 스위치’입니다.

- 게이트에 **‘1’ (높은 전압)**이 들어오면 스위치가 ON되어 VDD(전원)가 다음 회로로 연결됩니다.  
- 게이트에 **‘0’ (낮은 전압)**이 들어오면 스위치가 OFF되어 GND(접지)에 연결되거나 회로가 끊어집니다.

### 에너지의 흐름

회로의 주된 에너지원은 **VDD(전원)**과 **GND(접지)**입니다.  
소프트웨어는 이 에너지를 ‘어떻게 흐르게 할지’를 결정하는 **능동적인(Active)** 역할을 합니다.

이 에너지는 소프트웨어의 제어에 따라 **저항(R)**, **인덕터(L)**, **커패시터(C)** 같은  
**수동적(Passive)** 소자들을 통과하며 원하는 동작을 수행합니다.

---

### 💡 결론 요약

> 프로그램 코드(SW)가 0과 1의 신호를 만들면  
> → 이 신호가 전압으로 바뀌어  
> → MOSFET 스위치를 켜고 끄며  
> → 실제 하드웨어 회로에 전기를 흐르게 하거나 차단한다.  

이것이 바로 논리회로의 가장 기본적인 개념이며,  
모든 디지털 시스템이 작동하는 핵심 원리입니다.  

Verilog로 코딩하는 것은 바로 이러한 스위치들의 연결과 동작을 설계하는 과정이라고 볼 수 있습니다.

---

## 3. 하드웨어를 구성하는 4대 소자: R, L, C, Switch

이번 페이지에서는 하드웨어의 물리적 기반을 이루는 네 가지 기본 소자를 다룹니다.

Verilog로 아무리 복잡한 회로를 설계하더라도,  
실제 칩으로 만들어질 때는 결국 이 **R, L, C, Switch**의 특성에 의해 성능이 결정됩니다.

---

### 1️⃣ 저항 (Resistor, R) 🔌

**역할:** 전류의 흐름을 방해하는 성분  
**물리적 의미:**  
세상의 모든 금속은 고유의 저항값(ρ, resistivity)을 가지고 있습니다.  
신호가 전달되는 **선(wire)**이 길어질수록(L ↑), 그리고 얇을수록(D ↓), 저항은 커집니다.

**핵심 포인트:**  
회로가 복잡해지고 배선이 길어질수록 신호가 약해지거나 전력 소모가 커질 수 있습니다.

---

### 2️⃣ 커패시턴스 (Capacitance, C) 🔋

**역할:** 전하(electric charge)를 일시적으로 저장하는 성분 (작은 배터리처럼 작동)  
**물리적 의미:**  
두 개의 금속 도체가 가까이 마주 보면 그 사이에 **커패시턴스가 자연적으로 형성**됩니다.  
칩 내부의 수많은 배선들 사이에도 항상 존재하죠.

**핵심:**  
커패시턴스는 **신호 지연(Signal Delay)**의 주된 원인입니다.  

‘ON’ 신호를 보낼 때 커패시터가 완전히 충전될 때까지 전압이 서서히 상승하고,  
‘OFF’ 신호에서도 서서히 방전됩니다.  

이 충/방전 시간 때문에 신호가 0↔1로 즉시 바뀌지 못하고,  
결국 이 지연이 **RC Delay**를 만들어 칩의 최고 동작 속도를 결정합니다.

---

### 3️⃣ 인덕턴스 (Inductance, L) 🌀

**역할:** 전류의 변화를 방해하는 성분  
**물리적 의미:**  
모든 전선은 약간의 인덕턴스를 가지며, 전선을 꼬거나 감으면 그 효과가 커집니다.

**핵심:**  
인덕턴스는 주로 **고주파 신호의 노이즈나 왜곡**을 일으키는 원인이 됩니다.  
고속 회로나 RF 시스템에서는 반드시 고려해야 하는 요소입니다.

---

### 4️⃣ 스위치 (Switch) 💡

**역할:** 신호를 연결(ON)하거나 끊는(OFF) 역할  
**물리적 의미:**  
현대 디지털 회로에서는 이 스위치 역할을 **트랜지스터(MOSFET)**가 담당합니다.

트랜지스터는 반도체로 만들어져 있고,  
전기적 신호(전압)에 따라 ON/OFF 상태를 제어할 수 있습니다.

**핵심:**  
이전 슬라이드에서 본 것처럼, 소프트웨어의 0과 1 명령이  
바로 이 스위치를 켜고 끄는 동작으로 변환되어 모든 논리 연산을 수행합니다.

---

### 💡 요약

- **Switch (트랜지스터)** → 의도적으로 사용하는 **능동 소자(Active component)**  
- **R, L, C** → 재료의 특성상 **기생적으로 존재하는 수동 소자(Passive components)**  

> 논리회로 설계는 결국  
> “트랜지스터를 어떻게 조합해 논리를 구현할 것인가”를 고민하는 동시에,  
> “기생 R, L, C에 의한 신호 지연이나 왜곡을 어떻게 줄일 것인가”를 함께 고려하는 과정이다.

---

## 4. 시간과 상태(State): 논리회로의 동적 동작

이번 슬라이드는 논리회로가 **시간의 흐름에 따라 변화**한다는 점을 강조합니다.  
핵심 개념은 바로 **‘상태(State)’**입니다.

---

### 1️⃣ 아날로그 → 디지털 변환 과정

컴퓨터는 현실의 연속적인 아날로그 신호를 그대로 다룰 수 없습니다.  
따라서 다음 두 단계를 거쳐 디지털 신호로 변환합니다.

#### (1) 샘플링 (Sampling) 📈 – 시간의 이산화

아날로그 신호의 값을 일정한 시간 간격(Δt)마다 콕콕 찍어 측정하는 과정입니다.  
이 과정을 거치면 시간축이 연속이 아닌 **이산적(Discrete)** 데이터가 됩니다.

#### (2) 양자화 (Quantization) 📊 – 값의 이산화

샘플링된 값들은 여전히 소수점 등 다양한 값을 가집니다.  
이를 대표적인 몇 개의 전압 레벨로 강제 변환하는 것이 양자화입니다.  

예: “3V~5V는 모두 4V(Level 4)로 취급하자.”

이 과정을 통해 신호는 0, 1, 2, 3… 처럼 명확한 **디지털 값**으로 바뀝니다.

---

### 2️⃣ 상태(State)와 상태 천이(State Transition) ⚙️➡️⚙️

디지털 회로는 0과 1의 신호를 다루며, 시간의 흐름에 따라 상태가 변합니다.

- **상태(State):**  
  회로 내 모든 노드의 0/1 값 조합, 즉 회로의 스냅샷입니다.  
  (예: S₀, S₁, S₂…)

- **상태 천이(State Transition):**  
  회로는 클럭(Clock) 신호가 “똑딱” 할 때마다  
  현재 상태 Sₙ에서 다음 상태 Sₘ으로 이동합니다.  

  Verilog에서는 `always @(posedge clk)` 구문으로 표현됩니다.

- **출력(Output):**  
  현재 상태(Sₘ)에 따라 출력이 결정됩니다.  
  (`O = F(Sₘ)`)

예를 들어, 현재 상태가 ‘덧셈’이라면 조합회로가 두 수를 더한 결과를 출력으로 내보냅니다.

---

### 💡 핵심 문장

> “논리회로는 아날로그 신호를 디지털화하고,  
> 클럭에 맞춰 현재 상태에서 다음 상태로 이동하면서,  
> 각 상태에 맞는 출력을 만들어낸다.”  

이러한 구조가 바로 **유한상태기계(Finite State Machine, FSM)**이며,  
모든 디지털 시스템 설계의 근본적인 이론 모델입니다.

---

## 5. SW 명령에서 HW 동작까지의 실제 흐름


1. **소프트웨어 명령어 실행**  
   - 예: `MOV`, `AND`, `OR` 등  
   - CPU 제어 장치(Control Unit)가 이를 해석하여 내부 회로에 전기적 제어 신호 생성
2. **제어 신호 생성 → MOS 스위치 제어**  
   - 제어 신호(0/1 전압)가 논리 게이트로 전달  
   - 수많은 MOSFET 스위치들이 입력 전압에 따라 ON/OFF
3. **논리 연산 수행**  
   - 입력된 0/1에 따라 게이트의 출력이 결정
4. **출력 → 다음 로직 전달**  
   - 한 게이트의 출력은 다음 게이트의 입력으로 연결되어 연쇄적으로 동작
5. **최종 결과 출력**  
   - 복잡한 연산을 거쳐 LED, 모터, 디스플레이 등 실제 HW로 신호 전달

---

## 🧩 전체 흐름 요약

