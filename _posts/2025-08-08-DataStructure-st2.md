---
title: "1. Basic Concepts(2)"
excerpt: ""

categories:
  - DataStructure
tags:
  - tag1
  - tag2

permalink: /DataStructure/st2/

toc: true
toc_sticky: true

date: 2025-08-08
last_modified_at: 2025-08-08
---



## 1) 배열 기반 구현 — “index → element” 매핑
연속 메모리에 요소를 나란히 저장하여 **인덱스로 즉시 접근**한다.

### 시간 복잡도
| 연산 | 복잡도 | 비고 |
|---|---|---|
| 임의 접근 `A[i]` | **O(1)** | 인덱스 직접 접근 |
| 끝에 삽입/삭제 | **O(1) amortized** / 최악 **O(n)** | 용량 2배(doubling) 전략 시 평균 O(1), 재할당 시 O(n) |
| 중간 삽입/삭제 | **O(n)** | 뒤 요소 이동 필요 |
| 탐색 | 정렬 X: **O(n)** / 정렬 O: **O(log n)** | 이분 탐색 가능(정렬 시) |

### 장점
- **캐시 지역성** 우수 → 실제 실행 속도 유리  
- **오버헤드 작음**(포인터 저장 불필요)

### 단점
- 크기 변경 비용(재할당/복사)  
- **연속 공간 요구** → 큰 배열은 할당 실패 가능

### 전형적 용도
- **스택**, **원형 큐(배열)**, **동적 배열**(`vector`/`ArrayList`)  
- 빈번한 **랜덤 액세스**가 필요한 경우

---

## 2) 연결 리스트 기반 구현 — “node → next의 위치” 저장
각 노드는 데이터와 **다음 노드의 주소(포인터)**를 가진다. 메모리는 **불연속** 가능.

### 시간 복잡도
| 연산 | 복잡도 | 비고 |
|---|---|---|
| 임의 접근 | **O(n)** | 앞에서부터 순차 추적 |
| 앞/뒤 삽입·삭제 | **O(1)** | 포인터 갱신만; 뒤 삽입 **O(1)** 보장엔 `tail` 유지 |
| 노드 위치 알고 있을 때 삽입/삭제 | **O(1)** | 참조 노드 주어짐 |
| 탐색 | **O(n)** | 선형 탐색 |

### 장점
- **크기 가변**, **중간 삽입·삭제 빈번**할 때 유리  
- 연속 공간 불필요 → 외부 단편화에 덜 민감

### 단점
- **포인터 저장 오버헤드**(단일/이중 링크에 따라 1~2개)  
- **캐시 성능 저하**(pointer chasing)  
- 동적 할당/해제 비용, 파편화

### 전형적 용도
- 리스트 ADT에서 **중간 삽입/삭제가 많을 때**  
- **연속 할당이 어려운** 환경

---

## 3) 무엇을 언제 쓰는가 — 결정 규칙
- **랜덤 접근이 많다** → **배열**  
- **중간 삽입/삭제 빈번** → **연결 리스트**  
- **크기를 자주 키운다** → 둘 다 가능  
  - 배열은 **doubling**으로 amortized **O(1)** 유지  
  - **매우 큰 객체 복사 비용**이 문제면 **리스트**  
- **메모리 지역성/실행 속도**가 중요 → **배열**  
- **연속 할당이 어려움** → **리스트**

---

## 4) 대표 ADT를 두 뼈대로 구현할 때
| ADT | 배열 기반 | 리스트 기반 |
|---|---|---|
| **스택** | `top` 인덱스 이동 → `push/pop/top` **O(1)** amortized | 머리 삽입/삭제 → `push/pop/top` **O(1)** |
| **큐** | **원형 버퍼**로 `head/tail` 모듈러 갱신 → **O(1)** | `head/tail` 포인터 유지 → **O(1)** |
| **순차 리스트(List)** | 접근 **O(1)** / 중간 삽·삭 **O(n)** | 위치만 알면 삽·삭 **O(1)** / 접근 **O(n)** |

---

## 5) 구현 시 주의(실전 팁)
- **배열 동적 확장**: 용량 **2배** 전략으로 평균 **O(1)**.  
  축소는 **히스테리시스**(예: 사용률 1/4 이하에서만 축소)로 과도한 재할당 방지.
- **리스트 노드 크기**: 데이터가 작을수록 **포인터 오버헤드 비율↑**.  
  이중 연결 리스트는 포인터 **2개**.
- **캐시/분기 예측**: 배열의 **선형 순회 매우 빠름**, 리스트는 **pointer chasing 병목**.
- **메모리 소유권**: 리스트에 **구조체 포인터**를 저장할 때 **해제 주체(policy)**를 명확히 정할 것.
